====================================================================
                    BUFF系统架构与使用指南
====================================================================

【系统架构】
-----------
本项目采用"状态生命周期管理 + 属性修饰符"的统一架构：

1. StatusEffectComponent（状态效果组件）
   - 负责管理所有状态效果的生命周期
   - 持有 List<IStatusEffect> 列表
   - 每帧更新所有效果、处理过期移除
   - 提供 AddEffect/RemoveEffect 接口

2. IStatusEffect / StatusEffectInstanceBase（状态效果接口/基类）
   - 定义效果的生命周期方法：OnApply / OnTick / OnRemove
   - 支持持续时间、叠加控制
   - 提供 Refresh / Extend 方法

3. StatModifier（属性修饰符）
   - 用于修改角色属性的数值
   - 支持三种类型：Flat(固定加成) / PercentAdd(百分比累加) / PercentMult(百分比独立乘)
   - 公式：(Base + FlatSum) × (1 + PercentAddSum) × PercentMult1 × PercentMult2 × ...

4. CharacterStats（角色属性组件）
   - 持有所有 Stat（每个 Stat 内部有 List<StatModifier>）
   - 提供 RemoveAllModifiersFromSource(source) 批量移除修饰符


【效果类型分类】
---------------

一、数值型效果（必须使用 StatModifier）
   示例：
   - 移动速度增益/减益
   - 攻击力增益
   - 护甲增加（护盾）
   - 攻击速度加成
   
   实现方式：
   在 OnApply 时创建并添加 StatModifier，
   在 OnRemove 时移除 StatModifier。

二、持续伤害/治疗型效果
   示例：
   - 灼烧（持续伤害）
   - 中毒（持续伤害）
   - 回血光环
   
   实现方式：
   在 OnTick 中每帧调用 stats.TakeDamage() 或 stats.Heal()。

三、控制型效果
   示例：
   - 眩晕
   - 沉默
   - 定身
   
   实现方式：
   在 OnApply 时设置 StatusEffectComponent.SetStunned(true)，
   在 OnRemove 时恢复 SetStunned(false)。

四、特殊逻辑型效果（Hook 型）
   示例：
   - 伤害减免（通过 ModifyIncomingDamage 实现）
   - 攻击力增幅（通过 ModifyOutgoingDamage 实现）
   - 第一次受伤免疫
   
   实现方式：
   重写 ModifyIncomingDamage / ModifyOutgoingDamage 方法。


【创建新的 Buff/Debuff 步骤】
---------------------------

1. 创建 Definition（ScriptableObject）
   继承自 StatusEffectDefinitionSO
   定义配置字段（持续时间、数值、是否可叠加等）
   实现 CreateInstance() 返回运行时实例

2. 创建 Instance（运行时类）
   继承自 StatusEffectInstanceBase
   在构造器中保存 Definition 引用
   根据效果类型实现对应方法：
   - 数值型：OnApply 添加 StatModifier，OnRemove 移除
   - 持续伤害：OnTick 中造成伤害
   - 控制型：OnApply/OnRemove 设置控制标记
   - Hook 型：重写 ModifyIncomingDamage / ModifyOutgoingDamage

3. 在 Unity 中创建 Definition 资源
   右键 -> Create -> Character/Effects/[对应类型]
   配置参数（effectId、duration、isStackable 等）

4. 在技能/卡牌中引用
   在 SkillDefinition.Effects 列表中添加创建的 Definition
   或在技能执行器中动态创建并应用


【现有 Buff 示例】
-----------------

1. MoveSpeedBuff（移动速度增益）
   - Definition: MoveSpeedBuffDefinition
   - Instance: MoveSpeedBuffInstance
   - 类型：数值型（StatModifier）
   - 修改属性：MoveSpeed

2. AttackPowerBuff（攻击力增益）
   - Definition: AttackPowerBuffDefinition
   - Instance: AttackPowerBuffInstance
   - 类型：数值型（StatModifier）
   - 修改属性：AttackPower

3. SlowDebuff（减速减益）
   - Definition: SlowDebuffDefinition
   - Instance: SlowDebuffInstance
   - 类型：数值型（StatModifier）
   - 修改属性：MoveSpeed（负数）

4. ShieldBuff（护盾）
   - Definition: ShieldBuffDefinition
   - Instance: ShieldBuffInstance
   - 类型：数值型（StatModifier）
   - 修改属性：Armor

5. BurnEffect（灼烧）
   - Definition: BurnEffectDefinitionSO
   - Instance: BurnEffectInstance
   - 类型：持续伤害型
   - 实现：OnTick 中造成伤害

6. StunEffect（眩晕）
   - Definition: StunEffectDefinition
   - Instance: StunEffectInstance
   - 类型：控制型
   - 实现：SetStunned(true/false)

7. DamageReductionBuff（伤害减免）
   - Definition: DamageReductionBuffDefinition
   - Instance: DamageReductionBuffInstance
   - 类型：Hook 型
   - 实现：ModifyIncomingDamage


【技能执行器 Executor 示例】
----------------------------

1. BuffExecutor
   - 用途：给目标应用 Buff/Debuff
   - 支持：自动检测范围内目标 / 使用传入目标
   - 配置：targetTeam（Self/Friendly/Hostile/All）

2. DamageExecutor
   - 用途：对目标造成伤害
   - 支持：固定伤害 + 基于施法者攻击力的伤害
   - 配置：baseDamage、useAttackPower、attackPowerMultiplier

3. HealExecutor
   - 用途：治疗目标
   - 支持：固定治疗量 / 基于最大生命值百分比
   - 配置：baseHealAmount、useMaxHPPercent、maxHPPercent

4. AreaEffectExecutor
   - 用途：范围效果（伤害/Buff）
   - 支持：圆形范围检测 + 阵营过滤

5. CompositeExecutor
   - 用途：组合多个执行器，依次执行
   - 应用场景：复杂技能（造成伤害 + 应用减速 + 治疗自己）


【StatModifier 使用示例】
-------------------------

// 创建修饰符
var modifier = new StatModifier(
    value: 0.2f,              // 20% 增益
    type: StatModType.PercentAdd,
    source: this              // 来源（用于批量移除）
);

// 添加到属性
stats.MoveSpeed.AddModifier(modifier);

// 移除特定修饰符
stats.MoveSpeed.RemoveModifier(modifier);

// 移除来自某个源的所有修饰符
stats.RemoveAllModifiersFromSource(this);


【注意事项】
-----------
1. 所有数值型 Buff 必须使用 StatModifier，不要直接修改 Stat.BaseValue
2. StatModifier 的 source 字段很重要，建议传 this，方便后续批量移除
3. 在 OnRemove 中务必清理所有资源（移除修饰符、恢复控制状态等）
4. 可叠加效果（isStackable=true）会创建多个实例，不可叠加会刷新现有实例
5. CharacterStats.TakeDamage 已自动调用 ModifyIncomingDamage，无需手动调用
6. 创建新 Buff 时，优先使用现有分类（数值型/持续伤害/控制/Hook），避免混用


【示例代码：创建一个新的"攻速增益"Buff】
-------------------------------------

// 1. Definition
[CreateAssetMenu(fileName = "AttackSpeedBuffDefinition", menuName = "Character/Effects/Attack Speed Buff")]
public class AttackSpeedBuffDefinition : StatusEffectDefinitionSO
{
    [Header("攻速增益设置")]
    public float speedModifierValue = 0.3f;
    public StatModType modifierType = StatModType.PercentAdd;

    public override StatusEffectInstanceBase CreateInstance()
    {
        return new AttackSpeedBuffInstance(this);
    }
}

// 2. Instance
public class AttackSpeedBuffInstance : StatusEffectInstanceBase
{
    public override string EffectId => _def.effectId;

    private readonly AttackSpeedBuffDefinition _def;
    private StatModifier _modifier;

    public AttackSpeedBuffInstance(AttackSpeedBuffDefinition def)
        : base(def.duration, def.isStackable)
    {
        _def = def;
        _modifier = new StatModifier(_def.speedModifierValue, _def.modifierType, this);
    }

    public override void OnApply(CharacterStats stats, StatusEffectComponent comp)
    {
        base.OnApply(stats, comp);
        stats.AttackSpeed.AddModifier(_modifier);
    }

    public override void OnRemove(CharacterStats stats, StatusEffectComponent comp)
    {
        stats.AttackSpeed.RemoveModifier(_modifier);
        base.OnRemove(stats, comp);
    }
}

====================================================================
